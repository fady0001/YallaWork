// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'search_filter_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SearchStateF {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationsLoading,
    required TResult Function() specializationsLoadingMore,
    required TResult Function(SearchMmodelF searchMmodel)
        specializationsSuccess,
    required TResult Function(ErrorHandler errorHandler) specializationsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationsLoading,
    TResult? Function()? specializationsLoadingMore,
    TResult? Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult? Function(ErrorHandler errorHandler)? specializationsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationsLoading,
    TResult Function()? specializationsLoadingMore,
    TResult Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult Function(ErrorHandler errorHandler)? specializationsError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialF value) initial,
    required TResult Function(SearchStateLoadingF value) specializationsLoading,
    required TResult Function(_SpecializationsLoadingMoreF value)
        specializationsLoadingMore,
    required TResult Function(SearchStateSuccessF value) specializationsSuccess,
    required TResult Function(SearchStateErrorF value) specializationsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialF value)? initial,
    TResult? Function(SearchStateLoadingF value)? specializationsLoading,
    TResult? Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult? Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult? Function(SearchStateErrorF value)? specializationsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialF value)? initial,
    TResult Function(SearchStateLoadingF value)? specializationsLoading,
    TResult Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult Function(SearchStateErrorF value)? specializationsError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchStateFCopyWith<$Res> {
  factory $SearchStateFCopyWith(
          SearchStateF value, $Res Function(SearchStateF) then) =
      _$SearchStateFCopyWithImpl<$Res, SearchStateF>;
}

/// @nodoc
class _$SearchStateFCopyWithImpl<$Res, $Val extends SearchStateF>
    implements $SearchStateFCopyWith<$Res> {
  _$SearchStateFCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialFImplCopyWith<$Res> {
  factory _$$InitialFImplCopyWith(
          _$InitialFImpl value, $Res Function(_$InitialFImpl) then) =
      __$$InitialFImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialFImplCopyWithImpl<$Res>
    extends _$SearchStateFCopyWithImpl<$Res, _$InitialFImpl>
    implements _$$InitialFImplCopyWith<$Res> {
  __$$InitialFImplCopyWithImpl(
      _$InitialFImpl _value, $Res Function(_$InitialFImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialFImpl implements _InitialF {
  const _$InitialFImpl();

  @override
  String toString() {
    return 'SearchStateF.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialFImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationsLoading,
    required TResult Function() specializationsLoadingMore,
    required TResult Function(SearchMmodelF searchMmodel)
        specializationsSuccess,
    required TResult Function(ErrorHandler errorHandler) specializationsError,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationsLoading,
    TResult? Function()? specializationsLoadingMore,
    TResult? Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult? Function(ErrorHandler errorHandler)? specializationsError,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationsLoading,
    TResult Function()? specializationsLoadingMore,
    TResult Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult Function(ErrorHandler errorHandler)? specializationsError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialF value) initial,
    required TResult Function(SearchStateLoadingF value) specializationsLoading,
    required TResult Function(_SpecializationsLoadingMoreF value)
        specializationsLoadingMore,
    required TResult Function(SearchStateSuccessF value) specializationsSuccess,
    required TResult Function(SearchStateErrorF value) specializationsError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialF value)? initial,
    TResult? Function(SearchStateLoadingF value)? specializationsLoading,
    TResult? Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult? Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult? Function(SearchStateErrorF value)? specializationsError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialF value)? initial,
    TResult Function(SearchStateLoadingF value)? specializationsLoading,
    TResult Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult Function(SearchStateErrorF value)? specializationsError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialF implements SearchStateF {
  const factory _InitialF() = _$InitialFImpl;
}

/// @nodoc
abstract class _$$SearchStateLoadingFImplCopyWith<$Res> {
  factory _$$SearchStateLoadingFImplCopyWith(_$SearchStateLoadingFImpl value,
          $Res Function(_$SearchStateLoadingFImpl) then) =
      __$$SearchStateLoadingFImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SearchStateLoadingFImplCopyWithImpl<$Res>
    extends _$SearchStateFCopyWithImpl<$Res, _$SearchStateLoadingFImpl>
    implements _$$SearchStateLoadingFImplCopyWith<$Res> {
  __$$SearchStateLoadingFImplCopyWithImpl(_$SearchStateLoadingFImpl _value,
      $Res Function(_$SearchStateLoadingFImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SearchStateLoadingFImpl implements SearchStateLoadingF {
  const _$SearchStateLoadingFImpl();

  @override
  String toString() {
    return 'SearchStateF.specializationsLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchStateLoadingFImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationsLoading,
    required TResult Function() specializationsLoadingMore,
    required TResult Function(SearchMmodelF searchMmodel)
        specializationsSuccess,
    required TResult Function(ErrorHandler errorHandler) specializationsError,
  }) {
    return specializationsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationsLoading,
    TResult? Function()? specializationsLoadingMore,
    TResult? Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult? Function(ErrorHandler errorHandler)? specializationsError,
  }) {
    return specializationsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationsLoading,
    TResult Function()? specializationsLoadingMore,
    TResult Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult Function(ErrorHandler errorHandler)? specializationsError,
    required TResult orElse(),
  }) {
    if (specializationsLoading != null) {
      return specializationsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialF value) initial,
    required TResult Function(SearchStateLoadingF value) specializationsLoading,
    required TResult Function(_SpecializationsLoadingMoreF value)
        specializationsLoadingMore,
    required TResult Function(SearchStateSuccessF value) specializationsSuccess,
    required TResult Function(SearchStateErrorF value) specializationsError,
  }) {
    return specializationsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialF value)? initial,
    TResult? Function(SearchStateLoadingF value)? specializationsLoading,
    TResult? Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult? Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult? Function(SearchStateErrorF value)? specializationsError,
  }) {
    return specializationsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialF value)? initial,
    TResult Function(SearchStateLoadingF value)? specializationsLoading,
    TResult Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult Function(SearchStateErrorF value)? specializationsError,
    required TResult orElse(),
  }) {
    if (specializationsLoading != null) {
      return specializationsLoading(this);
    }
    return orElse();
  }
}

abstract class SearchStateLoadingF implements SearchStateF {
  const factory SearchStateLoadingF() = _$SearchStateLoadingFImpl;
}

/// @nodoc
abstract class _$$SpecializationsLoadingMoreFImplCopyWith<$Res> {
  factory _$$SpecializationsLoadingMoreFImplCopyWith(
          _$SpecializationsLoadingMoreFImpl value,
          $Res Function(_$SpecializationsLoadingMoreFImpl) then) =
      __$$SpecializationsLoadingMoreFImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SpecializationsLoadingMoreFImplCopyWithImpl<$Res>
    extends _$SearchStateFCopyWithImpl<$Res, _$SpecializationsLoadingMoreFImpl>
    implements _$$SpecializationsLoadingMoreFImplCopyWith<$Res> {
  __$$SpecializationsLoadingMoreFImplCopyWithImpl(
      _$SpecializationsLoadingMoreFImpl _value,
      $Res Function(_$SpecializationsLoadingMoreFImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SpecializationsLoadingMoreFImpl
    implements _SpecializationsLoadingMoreF {
  const _$SpecializationsLoadingMoreFImpl();

  @override
  String toString() {
    return 'SearchStateF.specializationsLoadingMore()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpecializationsLoadingMoreFImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationsLoading,
    required TResult Function() specializationsLoadingMore,
    required TResult Function(SearchMmodelF searchMmodel)
        specializationsSuccess,
    required TResult Function(ErrorHandler errorHandler) specializationsError,
  }) {
    return specializationsLoadingMore();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationsLoading,
    TResult? Function()? specializationsLoadingMore,
    TResult? Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult? Function(ErrorHandler errorHandler)? specializationsError,
  }) {
    return specializationsLoadingMore?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationsLoading,
    TResult Function()? specializationsLoadingMore,
    TResult Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult Function(ErrorHandler errorHandler)? specializationsError,
    required TResult orElse(),
  }) {
    if (specializationsLoadingMore != null) {
      return specializationsLoadingMore();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialF value) initial,
    required TResult Function(SearchStateLoadingF value) specializationsLoading,
    required TResult Function(_SpecializationsLoadingMoreF value)
        specializationsLoadingMore,
    required TResult Function(SearchStateSuccessF value) specializationsSuccess,
    required TResult Function(SearchStateErrorF value) specializationsError,
  }) {
    return specializationsLoadingMore(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialF value)? initial,
    TResult? Function(SearchStateLoadingF value)? specializationsLoading,
    TResult? Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult? Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult? Function(SearchStateErrorF value)? specializationsError,
  }) {
    return specializationsLoadingMore?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialF value)? initial,
    TResult Function(SearchStateLoadingF value)? specializationsLoading,
    TResult Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult Function(SearchStateErrorF value)? specializationsError,
    required TResult orElse(),
  }) {
    if (specializationsLoadingMore != null) {
      return specializationsLoadingMore(this);
    }
    return orElse();
  }
}

abstract class _SpecializationsLoadingMoreF implements SearchStateF {
  const factory _SpecializationsLoadingMoreF() =
      _$SpecializationsLoadingMoreFImpl;
}

/// @nodoc
abstract class _$$SearchStateSuccessFImplCopyWith<$Res> {
  factory _$$SearchStateSuccessFImplCopyWith(_$SearchStateSuccessFImpl value,
          $Res Function(_$SearchStateSuccessFImpl) then) =
      __$$SearchStateSuccessFImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SearchMmodelF searchMmodel});
}

/// @nodoc
class __$$SearchStateSuccessFImplCopyWithImpl<$Res>
    extends _$SearchStateFCopyWithImpl<$Res, _$SearchStateSuccessFImpl>
    implements _$$SearchStateSuccessFImplCopyWith<$Res> {
  __$$SearchStateSuccessFImplCopyWithImpl(_$SearchStateSuccessFImpl _value,
      $Res Function(_$SearchStateSuccessFImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? searchMmodel = null,
  }) {
    return _then(_$SearchStateSuccessFImpl(
      null == searchMmodel
          ? _value.searchMmodel
          : searchMmodel // ignore: cast_nullable_to_non_nullable
              as SearchMmodelF,
    ));
  }
}

/// @nodoc

class _$SearchStateSuccessFImpl implements SearchStateSuccessF {
  const _$SearchStateSuccessFImpl(this.searchMmodel);

  @override
  final SearchMmodelF searchMmodel;

  @override
  String toString() {
    return 'SearchStateF.specializationsSuccess(searchMmodel: $searchMmodel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchStateSuccessFImpl &&
            (identical(other.searchMmodel, searchMmodel) ||
                other.searchMmodel == searchMmodel));
  }

  @override
  int get hashCode => Object.hash(runtimeType, searchMmodel);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchStateSuccessFImplCopyWith<_$SearchStateSuccessFImpl> get copyWith =>
      __$$SearchStateSuccessFImplCopyWithImpl<_$SearchStateSuccessFImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationsLoading,
    required TResult Function() specializationsLoadingMore,
    required TResult Function(SearchMmodelF searchMmodel)
        specializationsSuccess,
    required TResult Function(ErrorHandler errorHandler) specializationsError,
  }) {
    return specializationsSuccess(searchMmodel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationsLoading,
    TResult? Function()? specializationsLoadingMore,
    TResult? Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult? Function(ErrorHandler errorHandler)? specializationsError,
  }) {
    return specializationsSuccess?.call(searchMmodel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationsLoading,
    TResult Function()? specializationsLoadingMore,
    TResult Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult Function(ErrorHandler errorHandler)? specializationsError,
    required TResult orElse(),
  }) {
    if (specializationsSuccess != null) {
      return specializationsSuccess(searchMmodel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialF value) initial,
    required TResult Function(SearchStateLoadingF value) specializationsLoading,
    required TResult Function(_SpecializationsLoadingMoreF value)
        specializationsLoadingMore,
    required TResult Function(SearchStateSuccessF value) specializationsSuccess,
    required TResult Function(SearchStateErrorF value) specializationsError,
  }) {
    return specializationsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialF value)? initial,
    TResult? Function(SearchStateLoadingF value)? specializationsLoading,
    TResult? Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult? Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult? Function(SearchStateErrorF value)? specializationsError,
  }) {
    return specializationsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialF value)? initial,
    TResult Function(SearchStateLoadingF value)? specializationsLoading,
    TResult Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult Function(SearchStateErrorF value)? specializationsError,
    required TResult orElse(),
  }) {
    if (specializationsSuccess != null) {
      return specializationsSuccess(this);
    }
    return orElse();
  }
}

abstract class SearchStateSuccessF implements SearchStateF {
  const factory SearchStateSuccessF(final SearchMmodelF searchMmodel) =
      _$SearchStateSuccessFImpl;

  SearchMmodelF get searchMmodel;
  @JsonKey(ignore: true)
  _$$SearchStateSuccessFImplCopyWith<_$SearchStateSuccessFImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchStateErrorFImplCopyWith<$Res> {
  factory _$$SearchStateErrorFImplCopyWith(_$SearchStateErrorFImpl value,
          $Res Function(_$SearchStateErrorFImpl) then) =
      __$$SearchStateErrorFImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ErrorHandler errorHandler});
}

/// @nodoc
class __$$SearchStateErrorFImplCopyWithImpl<$Res>
    extends _$SearchStateFCopyWithImpl<$Res, _$SearchStateErrorFImpl>
    implements _$$SearchStateErrorFImplCopyWith<$Res> {
  __$$SearchStateErrorFImplCopyWithImpl(_$SearchStateErrorFImpl _value,
      $Res Function(_$SearchStateErrorFImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorHandler = null,
  }) {
    return _then(_$SearchStateErrorFImpl(
      null == errorHandler
          ? _value.errorHandler
          : errorHandler // ignore: cast_nullable_to_non_nullable
              as ErrorHandler,
    ));
  }
}

/// @nodoc

class _$SearchStateErrorFImpl implements SearchStateErrorF {
  const _$SearchStateErrorFImpl(this.errorHandler);

  @override
  final ErrorHandler errorHandler;

  @override
  String toString() {
    return 'SearchStateF.specializationsError(errorHandler: $errorHandler)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchStateErrorFImpl &&
            (identical(other.errorHandler, errorHandler) ||
                other.errorHandler == errorHandler));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorHandler);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchStateErrorFImplCopyWith<_$SearchStateErrorFImpl> get copyWith =>
      __$$SearchStateErrorFImplCopyWithImpl<_$SearchStateErrorFImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() specializationsLoading,
    required TResult Function() specializationsLoadingMore,
    required TResult Function(SearchMmodelF searchMmodel)
        specializationsSuccess,
    required TResult Function(ErrorHandler errorHandler) specializationsError,
  }) {
    return specializationsError(errorHandler);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? specializationsLoading,
    TResult? Function()? specializationsLoadingMore,
    TResult? Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult? Function(ErrorHandler errorHandler)? specializationsError,
  }) {
    return specializationsError?.call(errorHandler);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? specializationsLoading,
    TResult Function()? specializationsLoadingMore,
    TResult Function(SearchMmodelF searchMmodel)? specializationsSuccess,
    TResult Function(ErrorHandler errorHandler)? specializationsError,
    required TResult orElse(),
  }) {
    if (specializationsError != null) {
      return specializationsError(errorHandler);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialF value) initial,
    required TResult Function(SearchStateLoadingF value) specializationsLoading,
    required TResult Function(_SpecializationsLoadingMoreF value)
        specializationsLoadingMore,
    required TResult Function(SearchStateSuccessF value) specializationsSuccess,
    required TResult Function(SearchStateErrorF value) specializationsError,
  }) {
    return specializationsError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialF value)? initial,
    TResult? Function(SearchStateLoadingF value)? specializationsLoading,
    TResult? Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult? Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult? Function(SearchStateErrorF value)? specializationsError,
  }) {
    return specializationsError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialF value)? initial,
    TResult Function(SearchStateLoadingF value)? specializationsLoading,
    TResult Function(_SpecializationsLoadingMoreF value)?
        specializationsLoadingMore,
    TResult Function(SearchStateSuccessF value)? specializationsSuccess,
    TResult Function(SearchStateErrorF value)? specializationsError,
    required TResult orElse(),
  }) {
    if (specializationsError != null) {
      return specializationsError(this);
    }
    return orElse();
  }
}

abstract class SearchStateErrorF implements SearchStateF {
  const factory SearchStateErrorF(final ErrorHandler errorHandler) =
      _$SearchStateErrorFImpl;

  ErrorHandler get errorHandler;
  @JsonKey(ignore: true)
  _$$SearchStateErrorFImplCopyWith<_$SearchStateErrorFImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
